#Import libraries needed for the seam carving algorithm
import numpy as np
from PIL import Image

SAMPLE_IMAGE_PATH = "sample_image.png"

#Returns the sum of delta_x ** 2 or delta_y ** 2 of the pixel in row i and column j
def deltaSum(image, identity, i, j, channel_count):
    #Stores of the sum of delta_xk ** 2 or delta_yk ** 2 for each channel k
	squared_sum = 0

    #Calculate the sum of delta_xk ** 2 for each channel k if the identity is set to 'x'
	if identity == 'x':
		for k in range(channel_count):
			squared_sum += (image[i][j+1][k] - image[i][j-1][k]) ** 2

    #Calculate the sum of delta_yk ** 2 for each channel k otherwise
	else:
		for k in range(channel_count):
			squared_sum += (image[i+1][j][k] - image[i-1][j][k]) ** 2

    #Return the squared delta sum
	return squared_sum

#Calculates the energy of the pixel at row i and column j of the image using its channels
def channelsEnergy(channels, image, i, j):
	#Calculate delta_x ** 2
	delta_x = deltaSum(image, 'x', i, j, len(channels))

	#Calculate delta_y ** 2
	delta_y = deltaSum(image, 'y', i, j, len(channels))

	#Return the energy of the pixel at row i and column j
	return (delta_x + delta_y)**(1/2)


def compute_energy(image: np.ndarray):
    """
    Compute the energy of a given pixel on the image.

    The energy of a pixel in an RGB-channel image is defined as:
        1000, if the pixel is on the edge
        sum([
            delta_xr ** 2,
            delta_xg ** 2,
            delta_xb ** 2,
            delta_yr ** 2,
            delta_yg ** 2,
            delta_yb ** 2,
        ]) ** (1 / 2), otherwise

    Notation: delta_xr indicates the difference in the R channel between
    adjacent pixels in the x (width) direction.

    This is a specific example for an RGB-channel image. Your code
    should work with a 2D image with arbitrary number of channels.

    Input:
        image: int type np.ndarray of the shape:
            (image height, image width, number of color channels)

    Return:
        energy: array of energies of the shape:
            (image_height, image_width)
    """

    #Initialize an energy array with the dimensions of the height and width of the image
    imageShape = image.shape
    energyArray = np.zeros((imageShape[0], imageShape[1]))

    #Fill the energy array
    for i in range(imageShape[0]):
        for j in range(imageShape[1]):
            if i == 0 or j == 0 or i == imageShape[0] - 1 or j == imageShape[1] - 1:
                energyArray[i,j] = 1000
            else:
                energyArray[i, j] = channelsEnergy(image[i][j], image, i, j)
    
    #Return the resulting energy array
    return energyArray


def find_vertical_seam(image: np.ndarray, energy=None):
    """
    Find the vertical "seam" with the least cumulative energy and return
    a list/array of the horizontal indices of the seam

    Input:
        image: int type np.ndarray of the shape:
            (image height, image width, number of color channels)
        energy: double type np.ndarray of the shape:
            (image height, image width)
            used for grading purposes to circumvent energy calculation

    Return:
        An (image height, ) sized array of integers ranging between
        [0, image width - 1]
    """

    # compute energy if not provided.
    if energy is None:
        energy = compute_energy(image)

        # Add a small random noise to the energy, which is generated by
        # an image assumed to contain integer values between [0, 255]
        # (thus may contain many duplicate values), to avoid variations
        # between implementations yielding different results.

        # Storing the internal random state for later reversion
        random_state = np.random.get_state()
        # Seeding the random state to 0
        np.random.seed(0)
        # generating the random noise
        noise = np.random.randn(*energy.shape) / (1000 * (image.size ** (0.5)))
        energy = energy + noise
        # Reverting the random state to what we started with
        np.random.set_state(random_state)

    #2-D array where each entry contains the minimum path cost from that position to the bottom
    min_paths = np.zeros(energy.shape)

    #Get the number of rows and columns in the energy matrix
    num_rows = energy.shape[0]
    num_cols = energy.shape[1]

    #Fill the bottom row of the min_paths array with the same values of the energy array
    for j in range(num_cols):
        min_paths[num_rows-1][j] = energy[num_rows-1][j]

    #Fill each entry above the bottom row in the min_paths array with the minimum of the three values below it
    for i in range(num_rows-2, -1, -1):
        for j in range(num_cols):
            min_paths[i][j] = min_vertical(min_paths, energy, i, j)

    #Contains the current shortest path weight (Initialized with a large positive value)
    cur_min = 9999999

    #Store the horizontal position of the current minimum path size (horizontal position = column number)
    cur_min_horizontal = 0

    #Store minimum value of the first row and its horizontal position
    for j in range(num_cols):
        if min_paths[0][j] < cur_min:
            cur_min = min_paths[0][j]
            cur_min_horizontal = j


    #Initialize array with minimum horizontal positions
    min_positions = np.zeros(num_rows, dtype=int)
    min_positions[0] = cur_min_horizontal

    for i in range(0, num_rows-1):
        #Store the row number (horizontal position) of the next minimum path (the row below in min_paths)
        cur_min_horizontal = next_vertical(min_paths, i, cur_min_horizontal)

        #Append the new minimum path horizontal position to min_positions
        min_positions[i+1] = cur_min_horizontal

    # Delete this line after you implemented your algorithm!
    return min_positions

#Helper function for find_vertical_seam, finds the minimum of the three values below row i an column j
#It then returns this minimum to the value plus the energy value at row i and column j
def min_vertical(min_paths, energy, i, j):
    #Get the number of rows and columns in the numpy array
    num_rows = min_paths.shape[0]
    num_cols = min_paths.shape[1]

    #Edge cases for when the pixel is at the far left or far right of the image
    if j == num_cols - 1:
        return min(min_paths[i+1][j-1], min_paths[i+1][j]) + energy[i][j]
    if j == 0:
        return min(min_paths[i+1][j+1], min_paths[i+1][j]) + energy[i][j]

    #Return the minimum of the three pixels just below the current pixel position plus the energy array value at row i and column j
    return min(min_paths[i+1][j-1], min_paths[i+1][j+1], min_paths[i+1][j]) + energy[i][j]

#Helper function for find_vertical_seam, finds the horizontal position of the minimum value of three positions below row i and column j
def next_vertical(np_array, i, j):
    #Get the number of rows and columns in the numpy array
    num_rows = np_array.shape[0]
    num_cols = np_array.shape[1]

    #Edge cases for when the pixel is at the far left or far right of the image, return minimum value's horizontal position (ith row)
    if j == num_cols - 1:
        if (min(np_array[i+1][j-1], np_array[i+1][j]) == np_array[i+1][j-1]):
            return j-1
        else:
            return j
    if j == 0:
        if (min(np_array[i+1][j+1], np_array[i+1][j]) == np_array[i+1][j+1]):
            return j+1
        else:
            return j

    #Return the horizontal position (ith row) of minimum of the three pixels just below the current pixel position
    min_value = min(np_array[i+1][j-1], np_array[i+1][j+1], np_array[i+1][j])
    if min_value == np_array[i+1][j-1]:
        return j-1
    elif min_value == np_array[i+1][j+1]:
        return j+1
    else:
        return j


def find_horizontal_seam(image: np.ndarray, energy=None):
    """
    Find the horizontal "seam" with the least cumulative energy and return
    a list/array of the vertical indices of the seam

    Input:
        image: int type np.ndarray of the shape:
            (image height, image width, number of color channels)
        energy: double type np.ndarray of the shape:
            (image height, image width)
            used for grading purposes to circumvent energy calculation

    Return:
        An (image width, ) sized array of integers ranging between
        [0, image height - 1]
    """

    # this is equivalent to finding the vertical seam on the transposed image
    # so we don't need to repeat ourselves
    return find_vertical_seam(image.transpose(1, 0, 2), energy=energy)


def main():
    """
    Generate a visualization of the energy and 2 visualizations
    of the seam carving algorithm.
    """

    # open image with pillow, an active fork of the defunct PIL library
    p = Image.open(SAMPLE_IMAGE_PATH)
    # image could be other modes like RGBA, YCbCr, or L or something
    p = p.convert(mode="RGB")
    # limit max size
    p.thumbnail(size=(800, 500))
    R, G, B = 0, 1, 2

    # -------------------- energy -------------------------------

    # convert image to an array. Since default datatype for an RGB
    # image is in unsigned 8 bit integer, convert it to a regular int
    # to avoid hard-to-debug shenanigans like over/underflow
    image = np.array(p).astype(int)
    # compute the energy. Since the boundary is 1000 and would reduce
    # the visibility of the more interesting parts after normalization,
    # crop the "frame" to improve visualization
    energy = compute_energy(image)[1:-1, 1:-1]
    # uncomment to see the log-adjusted intensity.
    # energy = np.log(energy + 1)

    # normalization for visualization
    # darken the least value to black
    energy -= np.min(energy)
    # lighten the greatest value to white
    energy = energy / np.max(energy)
    # fit the value between [0, 255]
    energy *= 256
    energy = np.floor(energy)
    energy[energy == 256] = 255

    # convert values to an image
    energy_visualization = Image.fromarray(energy.astype(np.uint8), mode="L")
    energy_visualization.save("energy.png")

    # -------------------- vertical carving ---------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 1
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []

    # cap number of seams to carve at 200
    for _ in range(min([200, original_shape[1]])):
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(np.arange(image.shape[0]))
        horizontal_indices = tuple(find_vertical_seam(image))
        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        image = image[mask].reshape((
            image.shape[0],
            image.shape[1] - 1,
            image.shape[2]
        ))

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))

    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("vertical_carving_final.png")

    # build GIF
    p.save(
        "vertical_carving.gif",
        save_all=True,
        append_images=sequence,
        # uncomment this line to create infinite looping GIF
        # loop=0,
        # uncomment this line to control the speed of GIF
        # duration=40,
    )

    # -------------------- horizontal carving -------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 0
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []

    # cap number of seams to carve at 200
    for _ in range(min([200, original_shape[0]])):
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(find_horizontal_seam(image))
        horizontal_indices = tuple(np.arange(image.shape[1]))
        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        # don't look at me I am hideous
        # (weird hack to make sure that pixels line up right)
        image = image.transpose(1, 0, 2)[mask.transpose(1, 0, 2)].reshape((
            image.shape[1],
            image.shape[0] - 1,
            image.shape[2],
        )).transpose(1, 0, 2)

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("horizontal_carving_final.png")

    # build GIF
    p.save(
        "horizontal_carving.gif",
        save_all=True,
        append_images=sequence,
        # uncomment this line to create infinite looping GIF
        # loop=0,
        # uncomment this line to control the speed of GIF
        # duration=40,
    )


if __name__ == "__main__":
    main()
